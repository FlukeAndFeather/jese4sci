---
title: "Parameterize your code"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
```

## What's a parameter?

### New vocabulary

- _parameter_ An input to a function 
- _encapsulate_ Take a complex procedure and hide it in a simple interface (e.g. a function)

_Parameters_ are inputs to functions. If a function is a recipe, then parameters are the ingredients. I could call `stir_fry(ingredients)` on `c("carrots", "tofu")` or on `c("chicken", "zucchini")`. You'll typically write functions when you have a piece of code you want to run multiple times on different inputs. Let's practice!

### Counting nucleotides

Congratulations, you've discovered the gene that makes koala bears so dang cute. It looks like this:

```{r}
koala_gene <- "AGCCTTAAATAACGACCTTC"
koala_gene
```

Your labmate wants to know the frequency of each nucleotide. Your challenge is to write a function that takes two parameters, `nucleo` and `sequence`, and returns the frequency of that nucleotide in the sequence. Here's a code chunk you can use to get started.

```{r}
nA <- gregexpr("A", koala_gene)
if (length(nA[[1]]) == 1 && nA[[1]] == -1) {
  nA <- 0
} else {
  nA <- length(nA[[1]])
}
nA
```

That code is kind of confusing for such a simple task, isn't it? It uses `gregexpr()` to search for _A_ in `koala_gene`. If you look up the help for `gregexpr()` it says:

> returns an integer vector of the same length as `text` giving the starting position of the first match or _-1_ if there is none

So first we call `gregexpr()`. Then, we check if there were no matches (i.e. we get a `-1`), in which case we set `nA` to 0. Otherwise, we set `nA` to the length of the matches vector. Woof! It'd be so much nicer if we had a function to _encapsulate_ that behavior and tuck it away for future use. Here's how we do that:

```{r}
n_nucleo <- function(nucleo, sequence) {
  result <- gregexpr(nucleo, sequence)
  if (length(result[[1]]) == 1 && result[[1]] == -1) {
    result <- 0
  } else {
    result <- length(result[[1]])
  }
  result
}
n_nucleo("A", koala_gene)
```

The code looks familiar, doesn't it? But we've changed a few key things to make the specific example more general. We _paramaterized_ the nucleotide ("A" in the example is now `nucleo`) and sequence (`koala_gene` is now `sequence`) and stuck it in a function. Calling `n_nucleo("A", koala_gene)` gets us the same result as the original. Now you have a tool for answering your labmate's question. How many of each nucleotide are there? Make a vector with four elements corresponding to A, C, G, and T frequencies, respectively.

```{r nucleo-freq, exercise=TRUE}
# Use n_nucleo()
```

```{r nucleo-freq-solution}
c(n_nucleo("A", koala_gene), 
  n_nucleo("C", koala_gene), 
  n_nucleo("G", koala_gene), 
  n_nucleo("T", koala_gene))
```

## Write your own

Now your labmate wants to know the GC content of a sequence (the fraction of the sequence that's _G_ or _C_). For example, the GC content of `AAG` is 0.33 and for `TGCCCATGGG` it's 0.7. Write a function that calculates the GC content for a sequence.

```{r gc-content, exercise=TRUE}
gc_content <- function(sequence) {
  
}
gc_content("AAG")
gc_content("TGCCCATGGG")
```

```{r gc-content-solution}
gc_content <- function(sequence) {
  (n_nucleo("C", sequence) + n_nucleo("G", sequence)) / nchar(sequence)
}
gc_content("AAG")
gc_content("TGCCCATGGG")
```

Now something a bit trickier. You read a paper that found the ancestral marsupial cuteness gene and you want to know how conserved it is in koalas. So you count up the number of point mutations:

```{r}
marsupial_gene <- "AGCCTTTCAACACGACCTTC"
koala_nucleos <- strsplit(koala_gene, "")[[1]]
marsupial_nucleos <- strsplit(marsupial_gene, "")[[1]]
n_mutations <- sum(koala_nucleos != marsupial_nucleos)
n_mutations
```

But as a wise and seasoned scientist, you know this won't be the last time you have to count point mutations. So as a service to both future you and the broader marsupial genomics community, you write a function to _encapsulate_ this logic.

```{r point-mutations, exercise=TRUE}
??? <- function(???) {
  ???
}
```

```{r point-mutations-solution}
point_mutations <- function(seq1, seq2) {
  seq1_nucleos <- strsplit(seq1, "")[[1]]
  seq2_nucleos <- strsplit(seq2, "")[[1]]
  sum(seq1_nucleos != seq2_nucleos)
}
```

## Recap

Congrats, you now know what a function's _parameters_ are and how a function can _encapsulate_ complex logic. Answer the questions in `01_parameterize.md` and submit on GitHub.
